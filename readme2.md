---方法调用方法---
栈帧：先调用的方法，在栈底
嵌套时，多个栈帧，递归调用，多个栈帧。

    本地方法栈
        描述的是本地方法出栈 入栈的信息
            native方法，c和c++实现的
    方法区：类信息、常量（1.7）、静态变量、JIT编译时代码
    Heap 堆：内存模型JMM
    1.8以前
        新生代 eden survivor0 survior1 8:1:1的比例
            涉及回收算法——复制回收算法
                         一块分配空间，一块始终不分配
                         回收时，把活着的移至对面，当前空间清空。
                分代机制、统计学结果，才分为3块
                基于理论：对象的生命周期不一样，98%的对象在minorGC
                         中会被回收掉。
                         分配担保，老年代为新生代GC担保。

                8:1:1时，利用率可达到90%
                1:1时，利用率才到50%

        老年代 新生代和老年代比例为1:2
        永久代 是方法区的实现。
    1.8之后
        新生代
        老年代
        Meta Space  规避永久代会溢出的问题，是一个ArrayList
                    可动态扩容，需要定义大小。
-------------------------------------
    什么样的对象要被GC？
判断算法
    --引用计数法
    循环引用，难以处理
    --可达性分析
    需要GC root 会指向一些东西
    遍历所有GC root的链上的对象，不在这个链上，则可被回收。
    --哪些能成为GC root 呢？
        1 虚拟机栈中本地变量表引用的对象
        2 方法区中
            类静态变量引用的对象
            常量引用的对象
        3 本地方法栈中JNI引用的对象
   --为什么这些对象，可成为GC Root？
    因为在运行时数据区内，这些对象在线程或线程中正在跑。
    ---不可达是不是一定就被回收？----
        finalize()方法，可以进行一次挽救。
        一个finalize()方法，仅可执行一次。
        用一个GC root 指向一下。



